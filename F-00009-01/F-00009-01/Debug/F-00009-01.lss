
F-00009-01.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000023a  00800100  0000e760  000007f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000760  0000e000  0000e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000105  0080033a  0080033a  00000a2e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a2e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000a60  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000108  00000000  00000000  00000aa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000f42  00000000  00000000  00000ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000004fa  00000000  00000000  00001aea  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005a7  00000000  00000000  00001fe4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000027c  00000000  00000000  0000258c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000412  00000000  00000000  00002808  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a6d  00000000  00000000  00002c1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000168  00000000  00000000  00003687  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000e000 <__vectors>:
    e000:	0c 94 70 70 	jmp	0xe0e0	; 0xe0e0 <__ctors_end>
    e004:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e008:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e00c:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e010:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e014:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e018:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e01c:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e020:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e024:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e028:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e02c:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e030:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e034:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e038:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e03c:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e040:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e044:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e048:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e04c:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e050:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e054:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e058:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e05c:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e060:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e064:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e068:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e06c:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e070:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e074:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e078:	0c 94 8d 70 	jmp	0xe11a	; 0xe11a <__bad_interrupt>
    e07c:	e8 72       	andi	r30, 0x28	; 40
    e07e:	42 72       	andi	r20, 0x22	; 34
    e080:	42 72       	andi	r20, 0x22	; 34
    e082:	dc 72       	andi	r29, 0x2C	; 44
    e084:	8a 72       	andi	r24, 0x2A	; 42
    e086:	42 72       	andi	r20, 0x22	; 34
    e088:	42 72       	andi	r20, 0x22	; 34
    e08a:	42 72       	andi	r20, 0x22	; 34
    e08c:	42 72       	andi	r20, 0x22	; 34
    e08e:	42 72       	andi	r20, 0x22	; 34
    e090:	42 72       	andi	r20, 0x22	; 34
    e092:	42 72       	andi	r20, 0x22	; 34
    e094:	97 72       	andi	r25, 0x27	; 39
    e096:	42 72       	andi	r20, 0x22	; 34
    e098:	42 72       	andi	r20, 0x22	; 34
    e09a:	a3 72       	andi	r26, 0x23	; 35
    e09c:	42 72       	andi	r20, 0x22	; 34
    e09e:	c8 72       	andi	r28, 0x28	; 40
    e0a0:	42 72       	andi	r20, 0x22	; 34
    e0a2:	42 72       	andi	r20, 0x22	; 34
    e0a4:	d2 72       	andi	r29, 0x22	; 34
    e0a6:	42 72       	andi	r20, 0x22	; 34
    e0a8:	42 72       	andi	r20, 0x22	; 34
    e0aa:	42 72       	andi	r20, 0x22	; 34
    e0ac:	42 72       	andi	r20, 0x22	; 34
    e0ae:	42 72       	andi	r20, 0x22	; 34
    e0b0:	42 72       	andi	r20, 0x22	; 34
    e0b2:	42 72       	andi	r20, 0x22	; 34
    e0b4:	42 72       	andi	r20, 0x22	; 34
    e0b6:	42 72       	andi	r20, 0x22	; 34
    e0b8:	42 72       	andi	r20, 0x22	; 34
    e0ba:	42 72       	andi	r20, 0x22	; 34
    e0bc:	e5 72       	andi	r30, 0x25	; 37
    e0be:	42 72       	andi	r20, 0x22	; 34
    e0c0:	42 72       	andi	r20, 0x22	; 34
    e0c2:	5b 72       	andi	r21, 0x2B	; 43
    e0c4:	42 72       	andi	r20, 0x22	; 34
    e0c6:	53 73       	andi	r21, 0x33	; 51
    e0c8:	42 72       	andi	r20, 0x22	; 34
    e0ca:	42 72       	andi	r20, 0x22	; 34
    e0cc:	42 72       	andi	r20, 0x22	; 34
    e0ce:	42 72       	andi	r20, 0x22	; 34
    e0d0:	84 72       	andi	r24, 0x24	; 36
    e0d2:	42 72       	andi	r20, 0x22	; 34
    e0d4:	42 72       	andi	r20, 0x22	; 34
    e0d6:	42 72       	andi	r20, 0x22	; 34
    e0d8:	42 72       	andi	r20, 0x22	; 34
    e0da:	42 72       	andi	r20, 0x22	; 34
    e0dc:	4f 72       	andi	r20, 0x2F	; 47
    e0de:	af 72       	andi	r26, 0x2F	; 47

0000e0e0 <__ctors_end>:
    e0e0:	11 24       	eor	r1, r1
    e0e2:	1f be       	out	0x3f, r1	; 63
    e0e4:	cf ef       	ldi	r28, 0xFF	; 255
    e0e6:	d0 e1       	ldi	r29, 0x10	; 16
    e0e8:	de bf       	out	0x3e, r29	; 62
    e0ea:	cd bf       	out	0x3d, r28	; 61

0000e0ec <__do_copy_data>:
    e0ec:	13 e0       	ldi	r17, 0x03	; 3
    e0ee:	a0 e0       	ldi	r26, 0x00	; 0
    e0f0:	b1 e0       	ldi	r27, 0x01	; 1
    e0f2:	e0 e6       	ldi	r30, 0x60	; 96
    e0f4:	f7 ee       	ldi	r31, 0xE7	; 231
    e0f6:	02 c0       	rjmp	.+4      	; 0xe0fc <__do_copy_data+0x10>
    e0f8:	05 90       	lpm	r0, Z+
    e0fa:	0d 92       	st	X+, r0
    e0fc:	aa 33       	cpi	r26, 0x3A	; 58
    e0fe:	b1 07       	cpc	r27, r17
    e100:	d9 f7       	brne	.-10     	; 0xe0f8 <__do_copy_data+0xc>

0000e102 <__do_clear_bss>:
    e102:	24 e0       	ldi	r18, 0x04	; 4
    e104:	aa e3       	ldi	r26, 0x3A	; 58
    e106:	b3 e0       	ldi	r27, 0x03	; 3
    e108:	01 c0       	rjmp	.+2      	; 0xe10c <.do_clear_bss_start>

0000e10a <.do_clear_bss_loop>:
    e10a:	1d 92       	st	X+, r1

0000e10c <.do_clear_bss_start>:
    e10c:	af 33       	cpi	r26, 0x3F	; 63
    e10e:	b2 07       	cpc	r27, r18
    e110:	e1 f7       	brne	.-8      	; 0xe10a <.do_clear_bss_loop>
    e112:	0e 94 23 72 	call	0xe446	; 0xe446 <main>
    e116:	0c 94 ae 73 	jmp	0xe75c	; 0xe75c <_exit>

0000e11a <__bad_interrupt>:
    e11a:	0c 94 00 70 	jmp	0xe000	; 0xe000 <__vectors>

0000e11e <VerifyFlash>:
	return 0;
}
*/
// VerifyFlash
void VerifyFlash(void)
{
    e11e:	0f 93       	push	r16
    e120:	1f 93       	push	r17
    e122:	cf 93       	push	r28
    e124:	df 93       	push	r29
	uint16_t i=0;
	uint8_t remainder = 0;
	uint8_t Data = 0;
	uint16_t Address = 0;
    e126:	20 e0       	ldi	r18, 0x00	; 0
    e128:	30 e0       	ldi	r19, 0x00	; 0
	return 0;
}
*/
// VerifyFlash
void VerifyFlash(void)
{
    e12a:	d0 e0       	ldi	r29, 0x00	; 0
    e12c:	18 c0       	rjmp	.+48     	; 0xe15e <VerifyFlash+0x40>
	while(Address < START_BOOT_ADDRESS_BYTES)
	{
		remainder = 0x00;
		for (i = 0; i < SPM_PAGESIZE; i++)
		{
			Data = pgm_read_byte ( Address + i );
    e12e:	94 91       	lpm	r25, Z
			remainder = (crc_table[Data^remainder] ^ (remainder << 8) ) & 0xFF;
    e130:	ac 2f       	mov	r26, r28
    e132:	a9 27       	eor	r26, r25
    e134:	b0 e0       	ldi	r27, 0x00	; 0
    e136:	a7 5f       	subi	r26, 0xF7	; 247
    e138:	bd 4f       	sbci	r27, 0xFD	; 253
    e13a:	cc 91       	ld	r28, X
    e13c:	31 96       	adiw	r30, 0x01	; 1
	uint8_t Data = 0;
	uint16_t Address = 0;
	while(Address < START_BOOT_ADDRESS_BYTES)
	{
		remainder = 0x00;
		for (i = 0; i < SPM_PAGESIZE; i++)
    e13e:	e0 17       	cp	r30, r16
    e140:	f1 07       	cpc	r31, r17
    e142:	a9 f7       	brne	.-22     	; 0xe12e <VerifyFlash+0x10>
		{
			Data = pgm_read_byte ( Address + i );
			remainder = (crc_table[Data^remainder] ^ (remainder << 8) ) & 0xFF;
		}
		RS232_Transmit_uint16(Address);
    e144:	c9 01       	movw	r24, r18
    e146:	0e 94 ea 70 	call	0xe1d4	; 0xe1d4 <RS232_Transmit_uint16>
		RS232_Transmit_Char(~remainder);
    e14a:	8c 2f       	mov	r24, r28
    e14c:	80 95       	com	r24
    e14e:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
		RS232_Transmit_Char_CR();
    e152:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
		Address+=SPM_PAGESIZE;
    e156:	98 01       	movw	r18, r16
{
	uint16_t i=0;
	uint8_t remainder = 0;
	uint8_t Data = 0;
	uint16_t Address = 0;
	while(Address < START_BOOT_ADDRESS_BYTES)
    e158:	01 15       	cp	r16, r1
    e15a:	10 4e       	sbci	r17, 0xE0	; 224
    e15c:	29 f0       	breq	.+10     	; 0xe168 <VerifyFlash+0x4a>
    e15e:	89 01       	movw	r16, r18
    e160:	13 95       	inc	r17
	return 0;
}
*/
// VerifyFlash
void VerifyFlash(void)
{
    e162:	f9 01       	movw	r30, r18
    e164:	cd 2f       	mov	r28, r29
    e166:	e3 cf       	rjmp	.-58     	; 0xe12e <VerifyFlash+0x10>
		RS232_Transmit_uint16(Address);
		RS232_Transmit_Char(~remainder);
		RS232_Transmit_Char_CR();
		Address+=SPM_PAGESIZE;
	}
	RS232_Transmit_Char(ACK);
    e168:	86 e0       	ldi	r24, 0x06	; 6
    e16a:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
	RS232_Transmit_Char_CR();
    e16e:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
	//#warning "Pouze Simulator"
	//remainder;
    e172:	df 91       	pop	r29
    e174:	cf 91       	pop	r28
    e176:	1f 91       	pop	r17
    e178:	0f 91       	pop	r16
    e17a:	08 95       	ret

0000e17c <RS232_Init>:
//RXD0

void RS232_Init( unsigned int baud )
{
	
	UBRR0H = (unsigned char)(baud>>8);							//Registr pro nastavenÌ vrchnÌch byt˘ rychlosti sÈriovÈ linky.
    e17c:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)baud;								//Registr pro nastavenÌ spodnÌch byt˘ rychlosti sÈriovÈ linky.
    e180:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);		//PovolenÌ v registru odesÌl·nÌ, p¯Ìjmu a povolenÌ p¯eruöenÌ p¯Ìjmu
    e184:	88 e9       	ldi	r24, 0x98	; 152
    e186:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);						//NastavenÌ R/T 8 bit˘ data, 1 stop bitu, asynchronnÌ p¯enos a bez parity.
    e18a:	86 e0       	ldi	r24, 0x06	; 6
    e18c:	80 93 c2 00 	sts	0x00C2, r24
    e190:	08 95       	ret

0000e192 <RS232_Receive_Status>:
/*				Procedura pro p¯Ìjem jednoho znaku a ukl·d·nÌ			*/
/*					z registru UDR do vr·cenÈ promÏnnÈ.					*/
//////////////////////////////////////////////////////////////////////////
uint8_t	RS232_Receive_Status(void)
{
	if(UCSR0A & (1<<RXC0))
    e192:	80 91 c0 00 	lds	r24, 0x00C0
    e196:	88 23       	and	r24, r24
    e198:	1c f4       	brge	.+6      	; 0xe1a0 <RS232_Receive_Status+0xe>
	{
		return UDR0;
    e19a:	80 91 c6 00 	lds	r24, 0x00C6
    e19e:	08 95       	ret
	}
	else
	{
		return 0;
    e1a0:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    e1a2:	08 95       	ret

0000e1a4 <RS232_Receive_Char>:

unsigned char RS232_Receive_Char( void )
{
  unsigned char data;
  while ( !(UCSR0A & (1<<RXC0)) );	//»ek·nÌ dokud nenÌ dokonËen p¯enos dat
    e1a4:	e0 ec       	ldi	r30, 0xC0	; 192
    e1a6:	f0 e0       	ldi	r31, 0x00	; 0
    e1a8:	80 81       	ld	r24, Z
    e1aa:	88 23       	and	r24, r24
    e1ac:	ec f7       	brge	.-6      	; 0xe1a8 <RS232_Receive_Char+0x4>
  data=UDR0;							//»tenÌ dat z registru UDR a ukl·d·nÌ do promÏnnÈ
    e1ae:	80 91 c6 00 	lds	r24, 0x00C6
  return data;						//Vr·cenÌ p¯ijmutÈho znaku
}
    e1b2:	08 95       	ret

0000e1b4 <RS232_Transmit_Char>:
/*		Procedura pro odesÌl·nÌ jednoho znaku po sÈriovÈ lince.			*/
//////////////////////////////////////////////////////////////////////////

void RS232_Transmit_Char( unsigned char data )
{
  while ( !( UCSR0A & (1<<UDRE0)) );	//»ek·nÌ dokud nenÌ pr·zdn˝ buffer
    e1b4:	e0 ec       	ldi	r30, 0xC0	; 192
    e1b6:	f0 e0       	ldi	r31, 0x00	; 0
    e1b8:	90 81       	ld	r25, Z
    e1ba:	95 ff       	sbrs	r25, 5
    e1bc:	fd cf       	rjmp	.-6      	; 0xe1b8 <RS232_Transmit_Char+0x4>
  UDR0 = data;						//NastavenÌ znaku do registru
    e1be:	80 93 c6 00 	sts	0x00C6, r24
    e1c2:	08 95       	ret

0000e1c4 <RS232_Transmit_uint8>:
}

// UINT8_T Data
void RS232_Transmit_uint8( uint8_t data )
{
	while ( !( UCSR0A & (1<<UDRE0)) );	//»ek·nÌ dokud nenÌ pr·zdn˝ buffer
    e1c4:	e0 ec       	ldi	r30, 0xC0	; 192
    e1c6:	f0 e0       	ldi	r31, 0x00	; 0
    e1c8:	90 81       	ld	r25, Z
    e1ca:	95 ff       	sbrs	r25, 5
    e1cc:	fd cf       	rjmp	.-6      	; 0xe1c8 <RS232_Transmit_uint8+0x4>
	UDR0 = data;						//NastavenÌ znaku do registru
    e1ce:	80 93 c6 00 	sts	0x00C6, r24
    e1d2:	08 95       	ret

0000e1d4 <RS232_Transmit_uint16>:
}

// UINT16_T Data
void RS232_Transmit_uint16( uint16_t data )
{
    e1d4:	cf 93       	push	r28
    e1d6:	c8 2f       	mov	r28, r24
	RS232_Transmit_uint8( data >> 8 );
    e1d8:	89 2f       	mov	r24, r25
    e1da:	0e 94 e2 70 	call	0xe1c4	; 0xe1c4 <RS232_Transmit_uint8>
	RS232_Transmit_uint8( data );
    e1de:	8c 2f       	mov	r24, r28
    e1e0:	0e 94 e2 70 	call	0xe1c4	; 0xe1c4 <RS232_Transmit_uint8>
}
    e1e4:	cf 91       	pop	r28
    e1e6:	08 95       	ret

0000e1e8 <RS232_Transmit_Char_CR>:


// Odeöle se pouze CR
void RS232_Transmit_Char_CR(void)
{
	while ( !( UCSR0A & (1<<UDRE0)) );	//»ek·nÌ dokud nenÌ pr·zdn˝ buffer
    e1e8:	e0 ec       	ldi	r30, 0xC0	; 192
    e1ea:	f0 e0       	ldi	r31, 0x00	; 0
    e1ec:	80 81       	ld	r24, Z
    e1ee:	85 ff       	sbrs	r24, 5
    e1f0:	fd cf       	rjmp	.-6      	; 0xe1ec <RS232_Transmit_Char_CR+0x4>
	UDR0 = 0x0D;						//NastavenÌ znaku do registru
    e1f2:	8d e0       	ldi	r24, 0x0D	; 13
    e1f4:	80 93 c6 00 	sts	0x00C6, r24
    e1f8:	08 95       	ret

0000e1fa <RS232_Transmit_String>:
//////////////////////////////////////////////////////////////////////////
/*			RozöÌ¯enÌ procedury pro odesÌl·nÌ jednoho znaku,			*/
/*						 na odesÌl·nÌ pole znak˘.						*/
//////////////////////////////////////////////////////////////////////////

void RS232_Transmit_String(char* StringPtr){
    e1fa:	cf 93       	push	r28
    e1fc:	df 93       	push	r29
    e1fe:	ec 01       	movw	r28, r24
	
	while(*StringPtr != 0x00)			//Opakov·nÌ cyklu dokud se nevypr·zdnÌ buffer
    e200:	88 81       	ld	r24, Y
    e202:	88 23       	and	r24, r24
    e204:	31 f0       	breq	.+12     	; 0xe212 <RS232_Transmit_String+0x18>
    e206:	21 96       	adiw	r28, 0x01	; 1
	{
		RS232_Transmit_Char(*StringPtr);		//VyuûitÌ procedury pro odesl·nÌ jednoho znaku
    e208:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
/*						 na odesÌl·nÌ pole znak˘.						*/
//////////////////////////////////////////////////////////////////////////

void RS232_Transmit_String(char* StringPtr){
	
	while(*StringPtr != 0x00)			//Opakov·nÌ cyklu dokud se nevypr·zdnÌ buffer
    e20c:	89 91       	ld	r24, Y+
    e20e:	81 11       	cpse	r24, r1
    e210:	fb cf       	rjmp	.-10     	; 0xe208 <RS232_Transmit_String+0xe>
	{
		RS232_Transmit_Char(*StringPtr);		//VyuûitÌ procedury pro odesl·nÌ jednoho znaku
		StringPtr++;					//PosunutÌ o dalöÌ znak
	}
	
}
    e212:	df 91       	pop	r29
    e214:	cf 91       	pop	r28
    e216:	08 95       	ret

0000e218 <RS232_Transmit_String_CR>:
//////////////////////////////////////////////////////////////////////////
/*				 Upraven· procedura odesÌl·nÌ pole znak˘				*/
/*			s p¯idan˝m ukonËovacÌm znakem <CR> pro AT p¯Ìkazy.			*/
//////////////////////////////////////////////////////////////////////////

void RS232_Transmit_String_CR(char* StringPtr){
    e218:	cf 93       	push	r28
    e21a:	df 93       	push	r29
    e21c:	ec 01       	movw	r28, r24
	
	while(*StringPtr != 0x00)			//Opakov·nÌ cyklu dokud se nevypr·zdnÌ buffer
    e21e:	88 81       	ld	r24, Y
    e220:	88 23       	and	r24, r24
    e222:	31 f0       	breq	.+12     	; 0xe230 <RS232_Transmit_String_CR+0x18>
    e224:	21 96       	adiw	r28, 0x01	; 1
	{
		RS232_Transmit_Char(*StringPtr);		//VyuûitÌ procedury pro odesÌl·nÌ jednoho znaku
    e226:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
/*			s p¯idan˝m ukonËovacÌm znakem <CR> pro AT p¯Ìkazy.			*/
//////////////////////////////////////////////////////////////////////////

void RS232_Transmit_String_CR(char* StringPtr){
	
	while(*StringPtr != 0x00)			//Opakov·nÌ cyklu dokud se nevypr·zdnÌ buffer
    e22a:	89 91       	ld	r24, Y+
    e22c:	81 11       	cpse	r24, r1
    e22e:	fb cf       	rjmp	.-10     	; 0xe226 <RS232_Transmit_String_CR+0xe>
	{
		RS232_Transmit_Char(*StringPtr);		//VyuûitÌ procedury pro odesÌl·nÌ jednoho znaku
		StringPtr++;					//PosunutÌ o dalöÌ znak
	}
	RS232_Transmit_Char(0x0D);				//Na konci odesl·n znak <CR>
    e230:	8d e0       	ldi	r24, 0x0D	; 13
    e232:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
}
    e236:	df 91       	pop	r29
    e238:	cf 91       	pop	r28
    e23a:	08 95       	ret

0000e23c <FirstFunction>:
}

// PrvnÌ funkce, kter· zajistÌ odesl·nÌ informacÌ
void FirstFunction(void)
{
	for (cnt = 0; cnt < 250; cnt++)
    e23c:	10 92 3e 03 	sts	0x033E, r1
    e240:	10 92 3d 03 	sts	0x033D, r1
	//#warning "Pouze Simulator"
	//for (cnt = 0; cnt < 2; cnt++)
	{
		if (RS232_Receive_Status() == 'P')
    e244:	0e 94 c9 70 	call	0xe192	; 0xe192 <RS232_Receive_Status>
    e248:	80 35       	cpi	r24, 0x50	; 80
    e24a:	41 f4       	brne	.+16     	; 0xe25c <FirstFunction+0x20>
		{
			RS232_Transmit_String_CR("AtomTraceBootLoader");
    e24c:	89 e0       	ldi	r24, 0x09	; 9
    e24e:	93 e0       	ldi	r25, 0x03	; 3
    e250:	0e 94 0c 71 	call	0xe218	; 0xe218 <RS232_Transmit_String_CR>
			BootStatus = 1;
    e254:	81 e0       	ldi	r24, 0x01	; 1
    e256:	80 93 3a 03 	sts	0x033A, r24
    e25a:	08 95       	ret
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    e25c:	86 e6       	ldi	r24, 0x66	; 102
    e25e:	9e e0       	ldi	r25, 0x0E	; 14
    e260:	01 97       	sbiw	r24, 0x01	; 1
    e262:	f1 f7       	brne	.-4      	; 0xe260 <FirstFunction+0x24>
    e264:	00 00       	nop
}

// PrvnÌ funkce, kter· zajistÌ odesl·nÌ informacÌ
void FirstFunction(void)
{
	for (cnt = 0; cnt < 250; cnt++)
    e266:	80 91 3d 03 	lds	r24, 0x033D
    e26a:	90 91 3e 03 	lds	r25, 0x033E
    e26e:	01 96       	adiw	r24, 0x01	; 1
    e270:	90 93 3e 03 	sts	0x033E, r25
    e274:	80 93 3d 03 	sts	0x033D, r24
    e278:	8a 3f       	cpi	r24, 0xFA	; 250
    e27a:	91 05       	cpc	r25, r1
    e27c:	18 f3       	brcs	.-58     	; 0xe244 <FirstFunction+0x8>
	}
	// Pouze pro pozici Testov·nÌ simul·toru
	//#warning	"Pouze Simulator";
	//BootStatus = 1;
	
	if(!BootStatus)
    e27e:	80 91 3a 03 	lds	r24, 0x033A
    e282:	81 11       	cpse	r24, r1
    e284:	02 c0       	rjmp	.+4      	; 0xe28a <FirstFunction+0x4e>
uint8_t SOFTWARE_IDENTIFIER[9]="VA000001";

// SkoËenÌ na adresu 0x0000
void	jumpaddress(void)
{
	asm("jmp 0x0000");
    e286:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
    e28a:	08 95       	ret

0000e28c <ChipErase>:
}

// Vymaz·nÌ celÈ aplikaËnÌ pamÏti
void ChipErase(void)
{
	uint16_t	address = 0x0000, konec = 0x0000;
    e28c:	e0 e0       	ldi	r30, 0x00	; 0
    e28e:	f0 e0       	ldi	r31, 0x00	; 0
	// Maûe od adresy 0x0000 po koneËnou adresu Bootloaderu
	while (address < konec)
	{
		// Vymaûe p¯Ìsluönou adresu
		
		boot_page_erase(address);
    e290:	83 e0       	ldi	r24, 0x03	; 3
    e292:	80 93 57 00 	sts	0x0057, r24
    e296:	e8 95       	spm
		boot_spm_busy_wait();
    e298:	07 b6       	in	r0, 0x37	; 55
    e29a:	00 fc       	sbrc	r0, 0
    e29c:	fd cf       	rjmp	.-6      	; 0xe298 <ChipErase+0xc>
		address += SPM_PAGESIZE;
    e29e:	f3 95       	inc	r31
void ChipErase(void)
{
	uint16_t	address = 0x0000, konec = 0x0000;
	konec = END_APP_ADDRESS_BYTES;
	// Maûe od adresy 0x0000 po koneËnou adresu Bootloaderu
	while (address < konec)
    e2a0:	e1 15       	cp	r30, r1
    e2a2:	90 ee       	ldi	r25, 0xE0	; 224
    e2a4:	f9 07       	cpc	r31, r25
    e2a6:	a9 f7       	brne	.-22     	; 0xe292 <ChipErase+0x6>
		
		boot_page_erase(address);
		boot_spm_busy_wait();
		address += SPM_PAGESIZE;
	}
}
    e2a8:	08 95       	ret

0000e2aa <EepromErase>:

void EepromErase(void)
{
    e2aa:	cf 93       	push	r28
    e2ac:	df 93       	push	r29
	uint16_t	address = 0x0000, konec = 0x0000;
    e2ae:	c0 e0       	ldi	r28, 0x00	; 0
    e2b0:	d0 e0       	ldi	r29, 0x00	; 0
	konec = END_EEPROM_ADDRESS;
	// Maûe od adresy 0x0000 po koneËnou adresu Bootloaderu
	while (address < konec)
	{
		// Vymaûe p¯Ìsluönou adresu
		if(eeprom_read_byte(address) != 0xFF)
    e2b2:	ce 01       	movw	r24, r28
    e2b4:	0e 94 94 73 	call	0xe728	; 0xe728 <eeprom_read_byte>
    e2b8:	8f 3f       	cpi	r24, 0xFF	; 255
    e2ba:	21 f0       	breq	.+8      	; 0xe2c4 <EepromErase+0x1a>
		{
			eeprom_update_byte(address, 0xFF);
    e2bc:	6f ef       	ldi	r22, 0xFF	; 255
    e2be:	ce 01       	movw	r24, r28
    e2c0:	0e 94 9c 73 	call	0xe738	; 0xe738 <eeprom_update_byte>
		}
		address++;
    e2c4:	21 96       	adiw	r28, 0x01	; 1
void EepromErase(void)
{
	uint16_t	address = 0x0000, konec = 0x0000;
	konec = END_EEPROM_ADDRESS;
	// Maûe od adresy 0x0000 po koneËnou adresu Bootloaderu
	while (address < konec)
    e2c6:	c1 15       	cp	r28, r1
    e2c8:	88 e0       	ldi	r24, 0x08	; 8
    e2ca:	d8 07       	cpc	r29, r24
    e2cc:	91 f7       	brne	.-28     	; 0xe2b2 <EepromErase+0x8>
		{
			eeprom_update_byte(address, 0xFF);
		}
		address++;
	}
}
    e2ce:	df 91       	pop	r29
    e2d0:	cf 91       	pop	r28
    e2d2:	08 95       	ret

0000e2d4 <WriteFlashPages>:

// Verify EEPROM pamÏti

// Z·pis po pages do pamÏti Flash
void WriteFlashPages(uint16_t address, uint8_t	*Buffer)
{
    e2d4:	ef 92       	push	r14
    e2d6:	ff 92       	push	r15
    e2d8:	0f 93       	push	r16
    e2da:	1f 93       	push	r17
    e2dc:	cf 93       	push	r28
    e2de:	df 93       	push	r29
    e2e0:	8c 01       	movw	r16, r24
    e2e2:	7b 01       	movw	r14, r22
    e2e4:	f3 94       	inc	r15
    e2e6:	db 01       	movw	r26, r22
	for (i = 0; i < SPM_PAGESIZE; i += 2)
	{
		Data = *Buffer++;
		Data |= *Buffer++ << 8;
		// PlnÌ Page buffer (256 velikost u 644p)
		boot_page_fill (address + i, Data);
    e2e8:	81 e0       	ldi	r24, 0x01	; 1
    e2ea:	a8 01       	movw	r20, r16
    e2ec:	42 50       	subi	r20, 0x02	; 2
    e2ee:	51 09       	sbc	r21, r1
    e2f0:	46 1b       	sub	r20, r22
    e2f2:	57 0b       	sbc	r21, r23
{
	uint16_t i;
	uint16_t Data=0;
	for (i = 0; i < SPM_PAGESIZE; i += 2)
	{
		Data = *Buffer++;
    e2f4:	2c 91       	ld	r18, X
    e2f6:	12 96       	adiw	r26, 0x02	; 2
    e2f8:	fd 01       	movw	r30, r26
    e2fa:	e4 0f       	add	r30, r20
    e2fc:	f5 1f       	adc	r31, r21
    e2fe:	ed 01       	movw	r28, r26
    e300:	21 97       	sbiw	r28, 0x01	; 1
		Data |= *Buffer++ << 8;
    e302:	98 81       	ld	r25, Y
    e304:	30 e0       	ldi	r19, 0x00	; 0
    e306:	39 2b       	or	r19, r25
		// PlnÌ Page buffer (256 velikost u 644p)
		boot_page_fill (address + i, Data);
    e308:	09 01       	movw	r0, r18
    e30a:	80 93 57 00 	sts	0x0057, r24
    e30e:	e8 95       	spm
    e310:	11 24       	eor	r1, r1
// Z·pis po pages do pamÏti Flash
void WriteFlashPages(uint16_t address, uint8_t	*Buffer)
{
	uint16_t i;
	uint16_t Data=0;
	for (i = 0; i < SPM_PAGESIZE; i += 2)
    e312:	ea 16       	cp	r14, r26
    e314:	fb 06       	cpc	r15, r27
    e316:	71 f7       	brne	.-36     	; 0xe2f4 <WriteFlashPages+0x20>
		Data |= *Buffer++ << 8;
		// PlnÌ Page buffer (256 velikost u 644p)
		boot_page_fill (address + i, Data);
	}

	boot_page_write (address);     //NaplnÌ buffer
    e318:	85 e0       	ldi	r24, 0x05	; 5
    e31a:	f8 01       	movw	r30, r16
    e31c:	80 93 57 00 	sts	0x0057, r24
    e320:	e8 95       	spm
	boot_spm_busy_wait();       // »ek· dokud se neuvolnÌ
    e322:	07 b6       	in	r0, 0x37	; 55
    e324:	00 fc       	sbrc	r0, 0
    e326:	fd cf       	rjmp	.-6      	; 0xe322 <WriteFlashPages+0x4e>
}
    e328:	df 91       	pop	r29
    e32a:	cf 91       	pop	r28
    e32c:	1f 91       	pop	r17
    e32e:	0f 91       	pop	r16
    e330:	ff 90       	pop	r15
    e332:	ef 90       	pop	r14
    e334:	08 95       	ret

0000e336 <WriteEepromPages>:

// Z·pis po pages do pamÏti EEPROM
void WriteEepromPages(uint16_t address, uint8_t *Buffer)
{
    e336:	ef 92       	push	r14
    e338:	ff 92       	push	r15
    e33a:	0f 93       	push	r16
    e33c:	1f 93       	push	r17
    e33e:	cf 93       	push	r28
    e340:	df 93       	push	r29
    e342:	7b 01       	movw	r14, r22
    e344:	f3 94       	inc	r15
    e346:	eb 01       	movw	r28, r22
    e348:	01 97       	sbiw	r24, 0x01	; 1
    e34a:	8c 01       	movw	r16, r24
    e34c:	06 1b       	sub	r16, r22
    e34e:	17 0b       	sbc	r17, r23
	for (cnt = 0; cnt < PAGE_SIZE_EEPROM; cnt++)
	{
// 		Data = *Buffer++;
// 		Data |= *Buffer++ << 8;

		eeprom_update_byte(address++, *Buffer++);
    e350:	69 91       	ld	r22, Y+
    e352:	c8 01       	movw	r24, r16
    e354:	8c 0f       	add	r24, r28
    e356:	9d 1f       	adc	r25, r29
    e358:	0e 94 9c 73 	call	0xe738	; 0xe738 <eeprom_update_byte>

// Z·pis po pages do pamÏti EEPROM
void WriteEepromPages(uint16_t address, uint8_t *Buffer)
{
	uint16_t cnt=0;
	for (cnt = 0; cnt < PAGE_SIZE_EEPROM; cnt++)
    e35c:	ce 15       	cp	r28, r14
    e35e:	df 05       	cpc	r29, r15
    e360:	b9 f7       	brne	.-18     	; 0xe350 <WriteEepromPages+0x1a>
// 		Data = *Buffer++;
// 		Data |= *Buffer++ << 8;

		eeprom_update_byte(address++, *Buffer++);
	}
}
    e362:	df 91       	pop	r29
    e364:	cf 91       	pop	r28
    e366:	1f 91       	pop	r17
    e368:	0f 91       	pop	r16
    e36a:	ff 90       	pop	r15
    e36c:	ef 90       	pop	r14
    e36e:	08 95       	ret

0000e370 <ReadFlashPages>:

// »tenÌ pamÏti Flash
void ReadFlashPages(uint8_t end, uint16_t address)
{
    e370:	1f 93       	push	r17
    e372:	cf 93       	push	r28
    e374:	df 93       	push	r29
    e376:	18 2f       	mov	r17, r24
    e378:	eb 01       	movw	r28, r22
	uint16_t Last=0x0000;
	
	// Konec 0 - 0x0000 aû konec aplikaËnÌ Ë·sti
	// Konec 1 - ZaË·tek Bootloader Ë·sti aû konec
	// Konec 2 - Cel· pamÏù
	if (end == 0)
    e37a:	88 23       	and	r24, r24
    e37c:	21 f0       	breq	.+8      	; 0xe386 <ReadFlashPages+0x16>
	{
		address = START_APP_ADDRESS_BYTES;
	}
	
	Last = (START_BOOT_ADDRESS_BYTES - PAGE_SIZE);
	while (address <= Last)
    e37e:	61 30       	cpi	r22, 0x01	; 1
    e380:	7f 4d       	sbci	r23, 0xDF	; 223
    e382:	18 f0       	brcs	.+6      	; 0xe38a <ReadFlashPages+0x1a>
    e384:	26 c0       	rjmp	.+76     	; 0xe3d2 <ReadFlashPages+0x62>
	// Konec 0 - 0x0000 aû konec aplikaËnÌ Ë·sti
	// Konec 1 - ZaË·tek Bootloader Ë·sti aû konec
	// Konec 2 - Cel· pamÏù
	if (end == 0)
	{
		address = START_APP_ADDRESS_BYTES;
    e386:	c0 e0       	ldi	r28, 0x00	; 0
    e388:	d0 e0       	ldi	r29, 0x00	; 0
	
	Last = (START_BOOT_ADDRESS_BYTES - PAGE_SIZE);
	while (address <= Last)
	{
		
		RS232_Transmit_uint16(address);
    e38a:	ce 01       	movw	r24, r28
    e38c:	0e 94 ea 70 	call	0xe1d4	; 0xe1d4 <RS232_Transmit_uint16>
		for ( i = 0; i < SPM_PAGESIZE; i++)
    e390:	10 92 3c 03 	sts	0x033C, r1
    e394:	10 92 3b 03 	sts	0x033B, r1
    e398:	e0 e0       	ldi	r30, 0x00	; 0
    e39a:	f0 e0       	ldi	r31, 0x00	; 0
		{
			RS232_Transmit_Char(pgm_read_byte(address + i));
    e39c:	ec 0f       	add	r30, r28
    e39e:	fd 1f       	adc	r31, r29
    e3a0:	84 91       	lpm	r24, Z
    e3a2:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
	Last = (START_BOOT_ADDRESS_BYTES - PAGE_SIZE);
	while (address <= Last)
	{
		
		RS232_Transmit_uint16(address);
		for ( i = 0; i < SPM_PAGESIZE; i++)
    e3a6:	e0 91 3b 03 	lds	r30, 0x033B
    e3aa:	f0 91 3c 03 	lds	r31, 0x033C
    e3ae:	31 96       	adiw	r30, 0x01	; 1
    e3b0:	f0 93 3c 03 	sts	0x033C, r31
    e3b4:	e0 93 3b 03 	sts	0x033B, r30
    e3b8:	ef 3f       	cpi	r30, 0xFF	; 255
    e3ba:	f1 05       	cpc	r31, r1
    e3bc:	79 f3       	breq	.-34     	; 0xe39c <ReadFlashPages+0x2c>
    e3be:	70 f3       	brcs	.-36     	; 0xe39c <ReadFlashPages+0x2c>
		{
			RS232_Transmit_Char(pgm_read_byte(address + i));
		}
		RS232_Transmit_Char_CR();
    e3c0:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
		if (end == 1)
    e3c4:	11 30       	cpi	r17, 0x01	; 1
    e3c6:	29 f0       	breq	.+10     	; 0xe3d2 <ReadFlashPages+0x62>
		{
			break;
		}
		address += SPM_PAGESIZE;
    e3c8:	d3 95       	inc	r29
	{
		address = START_APP_ADDRESS_BYTES;
	}
	
	Last = (START_BOOT_ADDRESS_BYTES - PAGE_SIZE);
	while (address <= Last)
    e3ca:	c1 30       	cpi	r28, 0x01	; 1
    e3cc:	8f ed       	ldi	r24, 0xDF	; 223
    e3ce:	d8 07       	cpc	r29, r24
    e3d0:	e0 f2       	brcs	.-72     	; 0xe38a <ReadFlashPages+0x1a>
		{
			break;
		}
		address += SPM_PAGESIZE;
	}
}
    e3d2:	df 91       	pop	r29
    e3d4:	cf 91       	pop	r28
    e3d6:	1f 91       	pop	r17
    e3d8:	08 95       	ret

0000e3da <ReadEepromPages>:

void ReadEepromPages(uint8_t end, uint16_t address)
{
    e3da:	1f 93       	push	r17
    e3dc:	cf 93       	push	r28
    e3de:	df 93       	push	r29
    e3e0:	18 2f       	mov	r17, r24
    e3e2:	eb 01       	movw	r28, r22
	uint16_t Last=0x0000;
	
	if (end == 0)
    e3e4:	88 23       	and	r24, r24
    e3e6:	21 f0       	breq	.+8      	; 0xe3f0 <ReadEepromPages+0x16>
	{
		address = START_EEPROM_ADDRESS;
	}
	Last = (END_EEPROM_ADDRESS - PAGE_SIZE_EEPROM);
	
	while (address <= Last)
    e3e8:	61 30       	cpi	r22, 0x01	; 1
    e3ea:	77 40       	sbci	r23, 0x07	; 7
    e3ec:	18 f0       	brcs	.+6      	; 0xe3f4 <ReadEepromPages+0x1a>
    e3ee:	27 c0       	rjmp	.+78     	; 0xe43e <ReadEepromPages+0x64>
{
	uint16_t Last=0x0000;
	
	if (end == 0)
	{
		address = START_EEPROM_ADDRESS;
    e3f0:	c0 e0       	ldi	r28, 0x00	; 0
    e3f2:	d0 e0       	ldi	r29, 0x00	; 0
	}
	Last = (END_EEPROM_ADDRESS - PAGE_SIZE_EEPROM);
	
	while (address <= Last)
	{
		RS232_Transmit_uint16(address);
    e3f4:	ce 01       	movw	r24, r28
    e3f6:	0e 94 ea 70 	call	0xe1d4	; 0xe1d4 <RS232_Transmit_uint16>
		for ( i = 0; i < PAGE_SIZE_EEPROM; i++)
    e3fa:	10 92 3c 03 	sts	0x033C, r1
    e3fe:	10 92 3b 03 	sts	0x033B, r1
    e402:	80 e0       	ldi	r24, 0x00	; 0
    e404:	90 e0       	ldi	r25, 0x00	; 0
		{
			RS232_Transmit_Char(eeprom_read_byte(address + i));
    e406:	8c 0f       	add	r24, r28
    e408:	9d 1f       	adc	r25, r29
    e40a:	0e 94 94 73 	call	0xe728	; 0xe728 <eeprom_read_byte>
    e40e:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
	Last = (END_EEPROM_ADDRESS - PAGE_SIZE_EEPROM);
	
	while (address <= Last)
	{
		RS232_Transmit_uint16(address);
		for ( i = 0; i < PAGE_SIZE_EEPROM; i++)
    e412:	80 91 3b 03 	lds	r24, 0x033B
    e416:	90 91 3c 03 	lds	r25, 0x033C
    e41a:	01 96       	adiw	r24, 0x01	; 1
    e41c:	90 93 3c 03 	sts	0x033C, r25
    e420:	80 93 3b 03 	sts	0x033B, r24
    e424:	8f 3f       	cpi	r24, 0xFF	; 255
    e426:	91 05       	cpc	r25, r1
    e428:	71 f3       	breq	.-36     	; 0xe406 <ReadEepromPages+0x2c>
    e42a:	68 f3       	brcs	.-38     	; 0xe406 <ReadEepromPages+0x2c>
		{
			RS232_Transmit_Char(eeprom_read_byte(address + i));
		}
		RS232_Transmit_Char_CR();
    e42c:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
		if (end == 1)
    e430:	11 30       	cpi	r17, 0x01	; 1
    e432:	29 f0       	breq	.+10     	; 0xe43e <ReadEepromPages+0x64>
		{
			break;
		}
		address += E2PAGESIZE;
    e434:	28 96       	adiw	r28, 0x08	; 8
	{
		address = START_EEPROM_ADDRESS;
	}
	Last = (END_EEPROM_ADDRESS - PAGE_SIZE_EEPROM);
	
	while (address <= Last)
    e436:	c1 30       	cpi	r28, 0x01	; 1
    e438:	87 e0       	ldi	r24, 0x07	; 7
    e43a:	d8 07       	cpc	r29, r24
    e43c:	d8 f2       	brcs	.-74     	; 0xe3f4 <ReadEepromPages+0x1a>
		{
			break;
		}
		address += E2PAGESIZE;
	}
}
    e43e:	df 91       	pop	r29
    e440:	cf 91       	pop	r28
    e442:	1f 91       	pop	r17
    e444:	08 95       	ret

0000e446 <main>:

	uint8_t ID_Data=0;
	uint16_t	address=0x0000;
	uint8_t	all=0x00;
	
	cli();
    e446:	f8 94       	cli
	RS232_Init(RS232_115200);
    e448:	87 e0       	ldi	r24, 0x07	; 7
    e44a:	90 e0       	ldi	r25, 0x00	; 0
    e44c:	0e 94 be 70 	call	0xe17c	; 0xe17c <RS232_Init>
	
	// SpuötÏnÌ reûimu BOOTloaderu
	
	FirstFunction();
    e450:	0e 94 1e 71 	call	0xe23c	; 0xe23c <FirstFunction>
				RS232_Transmit_Char(ACK);
				RS232_Transmit_Char_CR();
				break;	
			//Read Signature
			case 's':
				RS232_Transmit_Char(boot_signature_byte_get(SIGNAT_BYTE_0));
    e454:	0f 2e       	mov	r0, r31
    e456:	f1 e2       	ldi	r31, 0x21	; 33
    e458:	8f 2e       	mov	r8, r31
    e45a:	f0 2d       	mov	r31, r0
				RS232_Transmit_Char(boot_signature_byte_get(SIGNAT_BYTE_1));				
    e45c:	68 94       	set
    e45e:	ee 24       	eor	r14, r14
    e460:	e1 f8       	bld	r14, 1
    e462:	f1 2c       	mov	r15, r1
				RS232_Transmit_Char(boot_signature_byte_get(SIGNAT_BYTE_2));				
    e464:	68 94       	set
    e466:	aa 24       	eor	r10, r10
    e468:	a2 f8       	bld	r10, 2
    e46a:	b1 2c       	mov	r11, r1
				RS232_Transmit_Char(ACK);
				RS232_Transmit_Char_CR();
				break;
			//Read Extended FUSE
			case 'Q':
				RS232_Transmit_Char(boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS));
    e46c:	0f 2e       	mov	r0, r31
    e46e:	f9 e0       	ldi	r31, 0x09	; 9
    e470:	9f 2e       	mov	r9, r31
    e472:	f0 2d       	mov	r31, r0
				RS232_Transmit_Char(ACK);
				RS232_Transmit_Char_CR();
				break;
			//Read High FUSE
			case 'N':
				RS232_Transmit_Char(boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS));
    e474:	0f 2e       	mov	r0, r31
    e476:	f3 e0       	ldi	r31, 0x03	; 3
    e478:	cf 2e       	mov	r12, r31
    e47a:	d1 2c       	mov	r13, r1
    e47c:	f0 2d       	mov	r31, r0
		
		switch (ID_Data)
		{
			// Read Lock Bits
			case 'r':
				RS232_Transmit_Char(boot_lock_fuse_bits_get(GET_LOCK_BITS));
    e47e:	66 24       	eor	r6, r6
    e480:	63 94       	inc	r6
    e482:	71 2c       	mov	r7, r1
	FirstFunction();
	
    while (1) 
    {
		
		ID_Data = RS232_Receive_Char();
    e484:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
		//#warning "Pouze Simulator"
		//ID_Data = 'g';
		
		switch (ID_Data)
    e488:	90 e0       	ldi	r25, 0x00	; 0
    e48a:	fc 01       	movw	r30, r24
    e48c:	e2 54       	subi	r30, 0x42	; 66
    e48e:	f1 09       	sbc	r31, r1
    e490:	e2 33       	cpi	r30, 0x32	; 50
    e492:	f1 05       	cpc	r31, r1
    e494:	b8 f7       	brcc	.-18     	; 0xe484 <main+0x3e>
    e496:	e2 5c       	subi	r30, 0xC2	; 194
    e498:	ff 48       	sbci	r31, 0x8F	; 143
    e49a:	0c 94 8e 73 	jmp	0xe71c	; 0xe71c <__tablejump2__>
		{
			// Read Lock Bits
			case 'r':
				RS232_Transmit_Char(boot_lock_fuse_bits_get(GET_LOCK_BITS));
    e49e:	f3 01       	movw	r30, r6
    e4a0:	90 92 57 00 	sts	0x0057, r9
    e4a4:	84 91       	lpm	r24, Z
    e4a6:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char(ACK);
    e4aa:	86 e0       	ldi	r24, 0x06	; 6
    e4ac:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char_CR();
    e4b0:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
				break;
    e4b4:	e7 cf       	rjmp	.-50     	; 0xe484 <main+0x3e>
			// Chip Erase
			case 'e':
				// P¯ijme 1 Byte, kter˝ rozhodne jestli EEPROM, Flash, nebo oboje
				ID_Data = RS232_Receive_Char();
    e4b6:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
				
				//#warning "Pouze Simulator"
				//ID_Data = 'F';
				// Chceme Flash nebo EEProm Vymazat
				switch(ID_Data)
    e4ba:	85 34       	cpi	r24, 0x45	; 69
    e4bc:	69 f0       	breq	.+26     	; 0xe4d8 <main+0x92>
    e4be:	86 34       	cpi	r24, 0x46	; 70
    e4c0:	19 f0       	breq	.+6      	; 0xe4c8 <main+0x82>
    e4c2:	81 34       	cpi	r24, 0x41	; 65
    e4c4:	d9 f4       	brne	.+54     	; 0xe4fc <main+0xb6>
    e4c6:	10 c0       	rjmp	.+32     	; 0xe4e8 <main+0xa2>
				{
					case 'F':
						ChipErase();
    e4c8:	0e 94 46 71 	call	0xe28c	; 0xe28c <ChipErase>
						RS232_Transmit_Char(ACK);
    e4cc:	86 e0       	ldi	r24, 0x06	; 6
    e4ce:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
						RS232_Transmit_Char_CR();
    e4d2:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
						break;
    e4d6:	d6 cf       	rjmp	.-84     	; 0xe484 <main+0x3e>
					case 'E':
						EepromErase();
    e4d8:	0e 94 55 71 	call	0xe2aa	; 0xe2aa <EepromErase>
						RS232_Transmit_Char(ACK);
    e4dc:	86 e0       	ldi	r24, 0x06	; 6
    e4de:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
						RS232_Transmit_Char_CR();
    e4e2:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
						break; 
    e4e6:	ce cf       	rjmp	.-100    	; 0xe484 <main+0x3e>
					case 'A':
						ChipErase();
    e4e8:	0e 94 46 71 	call	0xe28c	; 0xe28c <ChipErase>
						EepromErase();
    e4ec:	0e 94 55 71 	call	0xe2aa	; 0xe2aa <EepromErase>
						RS232_Transmit_Char(ACK);
    e4f0:	86 e0       	ldi	r24, 0x06	; 6
    e4f2:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
						RS232_Transmit_Char_CR();
    e4f6:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
						break;
    e4fa:	c4 cf       	rjmp	.-120    	; 0xe484 <main+0x3e>
					default:
						RS232_Transmit_Char(NAK);
    e4fc:	85 e1       	ldi	r24, 0x15	; 21
    e4fe:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
						RS232_Transmit_Char_CR();
    e502:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
					break;
    e506:	be cf       	rjmp	.-132    	; 0xe484 <main+0x3e>
				}
				break;
			// Write Lock Bits
			case 'l':
				WriteLockBits();
				RS232_Transmit_Char(NAK);
    e508:	85 e1       	ldi	r24, 0x15	; 21
    e50a:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char_CR();
    e50e:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
				break;
    e512:	b8 cf       	rjmp	.-144    	; 0xe484 <main+0x3e>
			//Read LOW FUSE
			case 'F':
				RS232_Transmit_Char(boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS));
    e514:	e0 e0       	ldi	r30, 0x00	; 0
    e516:	f0 e0       	ldi	r31, 0x00	; 0
    e518:	90 92 57 00 	sts	0x0057, r9
    e51c:	84 91       	lpm	r24, Z
    e51e:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char(ACK);
    e522:	86 e0       	ldi	r24, 0x06	; 6
    e524:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char_CR();
    e528:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
				break;
    e52c:	ab cf       	rjmp	.-170    	; 0xe484 <main+0x3e>
			//Read High FUSE
			case 'N':
				RS232_Transmit_Char(boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS));
    e52e:	f6 01       	movw	r30, r12
    e530:	90 92 57 00 	sts	0x0057, r9
    e534:	84 91       	lpm	r24, Z
    e536:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char(ACK);
    e53a:	86 e0       	ldi	r24, 0x06	; 6
    e53c:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char_CR();
    e540:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
				break;
    e544:	9f cf       	rjmp	.-194    	; 0xe484 <main+0x3e>
			//Read Extended FUSE
			case 'Q':
				RS232_Transmit_Char(boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS));
    e546:	f7 01       	movw	r30, r14
    e548:	90 92 57 00 	sts	0x0057, r9
    e54c:	84 91       	lpm	r24, Z
    e54e:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char(ACK);
    e552:	86 e0       	ldi	r24, 0x06	; 6
    e554:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char_CR();
    e558:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
				break;	
    e55c:	93 cf       	rjmp	.-218    	; 0xe484 <main+0x3e>
			//Read Signature
			case 's':
				RS232_Transmit_Char(boot_signature_byte_get(SIGNAT_BYTE_0));
    e55e:	e0 e0       	ldi	r30, 0x00	; 0
    e560:	f0 e0       	ldi	r31, 0x00	; 0
    e562:	80 92 57 00 	sts	0x0057, r8
    e566:	84 91       	lpm	r24, Z
    e568:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char(boot_signature_byte_get(SIGNAT_BYTE_1));				
    e56c:	f7 01       	movw	r30, r14
    e56e:	80 92 57 00 	sts	0x0057, r8
    e572:	84 91       	lpm	r24, Z
    e574:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char(boot_signature_byte_get(SIGNAT_BYTE_2));				
    e578:	f5 01       	movw	r30, r10
    e57a:	80 92 57 00 	sts	0x0057, r8
    e57e:	84 91       	lpm	r24, Z
    e580:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char(ACK);
    e584:	86 e0       	ldi	r24, 0x06	; 6
    e586:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char_CR();
    e58a:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
				break;
    e58e:	7a cf       	rjmp	.-268    	; 0xe484 <main+0x3e>
			// Return Software Identifier
			case 'S':
				RS232_Transmit_String(SOFTWARE_IDENTIFIER);
    e590:	80 e0       	ldi	r24, 0x00	; 0
    e592:	91 e0       	ldi	r25, 0x01	; 1
    e594:	0e 94 fd 70 	call	0xe1fa	; 0xe1fa <RS232_Transmit_String>
				RS232_Transmit_Char(ACK);
    e598:	86 e0       	ldi	r24, 0x06	; 6
    e59a:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char_CR();
    e59e:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
				break;
    e5a2:	70 cf       	rjmp	.-288    	; 0xe484 <main+0x3e>
			// Return Software Version
			case 'V':
				RS232_Transmit_String(BOOTLOADER_VERSION);
    e5a4:	8d e1       	ldi	r24, 0x1D	; 29
    e5a6:	93 e0       	ldi	r25, 0x03	; 3
    e5a8:	0e 94 fd 70 	call	0xe1fa	; 0xe1fa <RS232_Transmit_String>
				RS232_Transmit_Char(ACK);
    e5ac:	86 e0       	ldi	r24, 0x06	; 6
    e5ae:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
				RS232_Transmit_Char_CR();
    e5b2:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
				break;
    e5b6:	66 cf       	rjmp	.-308    	; 0xe484 <main+0x3e>
			// Exit from Bootloader
			case 'E':
				RS232_Transmit_String("Exit from BOOTLOADER. BYE");
    e5b8:	80 e2       	ldi	r24, 0x20	; 32
    e5ba:	93 e0       	ldi	r25, 0x03	; 3
    e5bc:	0e 94 fd 70 	call	0xe1fa	; 0xe1fa <RS232_Transmit_String>
				RS232_Transmit_Char_CR();
    e5c0:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
uint8_t SOFTWARE_IDENTIFIER[9]="VA000001";

// SkoËenÌ na adresu 0x0000
void	jumpaddress(void)
{
	asm("jmp 0x0000");
    e5c4:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
    e5c8:	5d cf       	rjmp	.-326    	; 0xe484 <main+0x3e>
				RS232_Transmit_Char_CR();
				jumpaddress();
				break;
			// Check Block Support (Vytvo¯enÌ Verify pamÏti)
			case 'b':
				VerifyFlash();
    e5ca:	0e 94 8f 70 	call	0xe11e	; 0xe11e <VerifyFlash>
				break;
    e5ce:	5a cf       	rjmp	.-332    	; 0xe484 <main+0x3e>
			// Write Data into Flash memory with specific Address
			case 'B':
				// P¯ijme 1 Byte, kter˝ rozhodne jestli 
				ID_Data = RS232_Receive_Char();
    e5d0:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
    e5d4:	c8 2f       	mov	r28, r24
				address = RS232_Receive_Char() << 8;
    e5d6:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
    e5da:	08 2f       	mov	r16, r24
    e5dc:	10 e0       	ldi	r17, 0x00	; 0
    e5de:	10 2f       	mov	r17, r16
    e5e0:	00 27       	eor	r16, r16
				address |= RS232_Receive_Char();
    e5e2:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
    e5e6:	08 2b       	or	r16, r24
				// Chceme Flash nebo EEProm naplnit daty
				switch(ID_Data)
    e5e8:	c5 34       	cpi	r28, 0x45	; 69
    e5ea:	81 f1       	breq	.+96     	; 0xe64c <main+0x206>
    e5ec:	c6 34       	cpi	r28, 0x46	; 70
    e5ee:	09 f0       	breq	.+2      	; 0xe5f2 <main+0x1ac>
    e5f0:	49 cf       	rjmp	.-366    	; 0xe484 <main+0x3e>
				{
					// »·st pro naprogramov·nÌ FLASH
					case 'F':
						// ZaplnÌ buffer o velikosti 1 str·nky
						for (cnt = 0; cnt < SPM_PAGESIZE; cnt++)
    e5f2:	10 92 3e 03 	sts	0x033E, r1
    e5f6:	10 92 3d 03 	sts	0x033D, r1
    e5fa:	c0 e0       	ldi	r28, 0x00	; 0
    e5fc:	d0 e0       	ldi	r29, 0x00	; 0
						{
							BufferFlash[cnt] = RS232_Receive_Char();
    e5fe:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
    e602:	c1 5c       	subi	r28, 0xC1	; 193
    e604:	dc 4f       	sbci	r29, 0xFC	; 252
    e606:	88 83       	st	Y, r24
				switch(ID_Data)
				{
					// »·st pro naprogramov·nÌ FLASH
					case 'F':
						// ZaplnÌ buffer o velikosti 1 str·nky
						for (cnt = 0; cnt < SPM_PAGESIZE; cnt++)
    e608:	c0 91 3d 03 	lds	r28, 0x033D
    e60c:	d0 91 3e 03 	lds	r29, 0x033E
    e610:	21 96       	adiw	r28, 0x01	; 1
    e612:	d0 93 3e 03 	sts	0x033E, r29
    e616:	c0 93 3d 03 	sts	0x033D, r28
    e61a:	cf 3f       	cpi	r28, 0xFF	; 255
    e61c:	d1 05       	cpc	r29, r1
    e61e:	79 f3       	breq	.-34     	; 0xe5fe <main+0x1b8>
    e620:	70 f3       	brcs	.-36     	; 0xe5fe <main+0x1b8>
						{
							BufferFlash[cnt] = RS232_Receive_Char();
						}
						// Pokud je zvolen· adresa vÏtöÌ jak 0xDF00 coû p¯i z·pisu 1 str·nky by jsme se dostali do Bootlaoder Ë·sti, tak buffer zahodÌ a odeöla NAK + CR
						if (address <= (START_BOOT_ADDRESS_BYTES - PAGE_SIZE))
    e622:	01 30       	cpi	r16, 0x01	; 1
    e624:	ff ed       	ldi	r31, 0xDF	; 223
    e626:	1f 07       	cpc	r17, r31
    e628:	58 f4       	brcc	.+22     	; 0xe640 <main+0x1fa>
						{
							WriteFlashPages(address, BufferFlash);
    e62a:	6f e3       	ldi	r22, 0x3F	; 63
    e62c:	73 e0       	ldi	r23, 0x03	; 3
    e62e:	c8 01       	movw	r24, r16
    e630:	0e 94 6a 71 	call	0xe2d4	; 0xe2d4 <WriteFlashPages>
							RS232_Transmit_Char(ACK);
    e634:	86 e0       	ldi	r24, 0x06	; 6
    e636:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
							RS232_Transmit_Char_CR();
    e63a:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
    e63e:	22 cf       	rjmp	.-444    	; 0xe484 <main+0x3e>
						} 
						else
						{
							RS232_Transmit_Char(NAK);
    e640:	85 e1       	ldi	r24, 0x15	; 21
    e642:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
							RS232_Transmit_Char_CR();
    e646:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
    e64a:	1c cf       	rjmp	.-456    	; 0xe484 <main+0x3e>
						}
						break;
					// »·st pro naprogramov·nÌ EEPROM
					case 'E':
						for (cnt = 0; cnt < PAGE_SIZE_EEPROM; cnt++)
    e64c:	10 92 3e 03 	sts	0x033E, r1
    e650:	10 92 3d 03 	sts	0x033D, r1
    e654:	c0 e0       	ldi	r28, 0x00	; 0
    e656:	d0 e0       	ldi	r29, 0x00	; 0
						{
							//BufferEeprom[cnt] = cnt;
							BufferEeprom[cnt] = RS232_Receive_Char();
    e658:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
    e65c:	c7 5f       	subi	r28, 0xF7	; 247
    e65e:	de 4f       	sbci	r29, 0xFE	; 254
    e660:	88 83       	st	Y, r24
							RS232_Transmit_Char_CR();
						}
						break;
					// »·st pro naprogramov·nÌ EEPROM
					case 'E':
						for (cnt = 0; cnt < PAGE_SIZE_EEPROM; cnt++)
    e662:	c0 91 3d 03 	lds	r28, 0x033D
    e666:	d0 91 3e 03 	lds	r29, 0x033E
    e66a:	21 96       	adiw	r28, 0x01	; 1
    e66c:	d0 93 3e 03 	sts	0x033E, r29
    e670:	c0 93 3d 03 	sts	0x033D, r28
    e674:	cf 3f       	cpi	r28, 0xFF	; 255
    e676:	d1 05       	cpc	r29, r1
    e678:	79 f3       	breq	.-34     	; 0xe658 <main+0x212>
    e67a:	70 f3       	brcs	.-36     	; 0xe658 <main+0x212>
						{
							//BufferEeprom[cnt] = cnt;
							BufferEeprom[cnt] = RS232_Receive_Char();
						}
						if (address <= (END_EEPROM_ADDRESS - PAGE_SIZE_EEPROM))
    e67c:	01 30       	cpi	r16, 0x01	; 1
    e67e:	87 e0       	ldi	r24, 0x07	; 7
    e680:	18 07       	cpc	r17, r24
    e682:	58 f4       	brcc	.+22     	; 0xe69a <main+0x254>
						{
							WriteEepromPages(address, BufferEeprom);
    e684:	69 e0       	ldi	r22, 0x09	; 9
    e686:	71 e0       	ldi	r23, 0x01	; 1
    e688:	c8 01       	movw	r24, r16
    e68a:	0e 94 9b 71 	call	0xe336	; 0xe336 <WriteEepromPages>
							RS232_Transmit_Char(ACK);
    e68e:	86 e0       	ldi	r24, 0x06	; 6
    e690:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
							RS232_Transmit_Char_CR();
    e694:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
    e698:	f5 ce       	rjmp	.-534    	; 0xe484 <main+0x3e>
						}
						else
						{
							RS232_Transmit_Char(NAK);
    e69a:	85 e1       	ldi	r24, 0x15	; 21
    e69c:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
							RS232_Transmit_Char_CR();
    e6a0:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
    e6a4:	ef ce       	rjmp	.-546    	; 0xe484 <main+0x3e>
						break;
				}
				break;
			case 'g':
				// P¯ijme 1 Byte, kter˝ rozhodne jestli 
				ID_Data = RS232_Receive_Char();
    e6a6:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
    e6aa:	18 2f       	mov	r17, r24
				address = RS232_Receive_Char() << 8;
    e6ac:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
    e6b0:	c8 2f       	mov	r28, r24
    e6b2:	d0 e0       	ldi	r29, 0x00	; 0
    e6b4:	dc 2f       	mov	r29, r28
    e6b6:	cc 27       	eor	r28, r28
				address |= RS232_Receive_Char();
    e6b8:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
    e6bc:	c8 2b       	or	r28, r24
				switch(ID_Data)
    e6be:	15 34       	cpi	r17, 0x45	; 69
    e6c0:	c1 f0       	breq	.+48     	; 0xe6f2 <main+0x2ac>
    e6c2:	16 34       	cpi	r17, 0x46	; 70
    e6c4:	09 f0       	breq	.+2      	; 0xe6c8 <main+0x282>
    e6c6:	de ce       	rjmp	.-580    	; 0xe484 <main+0x3e>
				{
					case 'F':
						// P¯eËtenÌ celÈ pamÏti dle stavovÈho automatu
						all = RS232_Receive_Char();
    e6c8:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
						if (address <= (START_BOOT_ADDRESS_BYTES - PAGE_SIZE))
    e6cc:	c1 30       	cpi	r28, 0x01	; 1
    e6ce:	9f ed       	ldi	r25, 0xDF	; 223
    e6d0:	d9 07       	cpc	r29, r25
    e6d2:	48 f4       	brcc	.+18     	; 0xe6e6 <main+0x2a0>
						{
							ReadFlashPages(all, address);
    e6d4:	be 01       	movw	r22, r28
    e6d6:	0e 94 b8 71 	call	0xe370	; 0xe370 <ReadFlashPages>
							RS232_Transmit_Char(ACK);
    e6da:	86 e0       	ldi	r24, 0x06	; 6
    e6dc:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
							RS232_Transmit_Char_CR();
    e6e0:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
    e6e4:	cf ce       	rjmp	.-610    	; 0xe484 <main+0x3e>
						}
						else
						{
							RS232_Transmit_Char(NAK);
    e6e6:	85 e1       	ldi	r24, 0x15	; 21
    e6e8:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
							RS232_Transmit_Char_CR();	
    e6ec:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
    e6f0:	c9 ce       	rjmp	.-622    	; 0xe484 <main+0x3e>
						}
						break;
					case 'E':
						all = RS232_Receive_Char();
    e6f2:	0e 94 d2 70 	call	0xe1a4	; 0xe1a4 <RS232_Receive_Char>
						if (address <= (START_EEPROM_ADDRESS - PAGE_SIZE_EEPROM))
    e6f6:	c1 30       	cpi	r28, 0x01	; 1
    e6f8:	ef ef       	ldi	r30, 0xFF	; 255
    e6fa:	de 07       	cpc	r29, r30
    e6fc:	48 f4       	brcc	.+18     	; 0xe710 <main+0x2ca>
						{
							ReadEepromPages(all, address);
    e6fe:	be 01       	movw	r22, r28
    e700:	0e 94 ed 71 	call	0xe3da	; 0xe3da <ReadEepromPages>
							RS232_Transmit_Char(ACK);
    e704:	86 e0       	ldi	r24, 0x06	; 6
    e706:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
							RS232_Transmit_Char_CR();
    e70a:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
    e70e:	ba ce       	rjmp	.-652    	; 0xe484 <main+0x3e>
						}
						else
						{
							RS232_Transmit_Char(NAK);
    e710:	85 e1       	ldi	r24, 0x15	; 21
    e712:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <RS232_Transmit_Char>
							RS232_Transmit_Char_CR();
    e716:	0e 94 f4 70 	call	0xe1e8	; 0xe1e8 <RS232_Transmit_Char_CR>
    e71a:	b4 ce       	rjmp	.-664    	; 0xe484 <main+0x3e>

0000e71c <__tablejump2__>:
    e71c:	ee 0f       	add	r30, r30
    e71e:	ff 1f       	adc	r31, r31
    e720:	05 90       	lpm	r0, Z+
    e722:	f4 91       	lpm	r31, Z
    e724:	e0 2d       	mov	r30, r0
    e726:	09 94       	ijmp

0000e728 <eeprom_read_byte>:
    e728:	f9 99       	sbic	0x1f, 1	; 31
    e72a:	fe cf       	rjmp	.-4      	; 0xe728 <eeprom_read_byte>
    e72c:	92 bd       	out	0x22, r25	; 34
    e72e:	81 bd       	out	0x21, r24	; 33
    e730:	f8 9a       	sbi	0x1f, 0	; 31
    e732:	99 27       	eor	r25, r25
    e734:	80 b5       	in	r24, 0x20	; 32
    e736:	08 95       	ret

0000e738 <eeprom_update_byte>:
    e738:	26 2f       	mov	r18, r22

0000e73a <eeprom_update_r18>:
    e73a:	f9 99       	sbic	0x1f, 1	; 31
    e73c:	fe cf       	rjmp	.-4      	; 0xe73a <eeprom_update_r18>
    e73e:	92 bd       	out	0x22, r25	; 34
    e740:	81 bd       	out	0x21, r24	; 33
    e742:	f8 9a       	sbi	0x1f, 0	; 31
    e744:	01 97       	sbiw	r24, 0x01	; 1
    e746:	00 b4       	in	r0, 0x20	; 32
    e748:	02 16       	cp	r0, r18
    e74a:	39 f0       	breq	.+14     	; 0xe75a <eeprom_update_r18+0x20>
    e74c:	1f ba       	out	0x1f, r1	; 31
    e74e:	20 bd       	out	0x20, r18	; 32
    e750:	0f b6       	in	r0, 0x3f	; 63
    e752:	f8 94       	cli
    e754:	fa 9a       	sbi	0x1f, 2	; 31
    e756:	f9 9a       	sbi	0x1f, 1	; 31
    e758:	0f be       	out	0x3f, r0	; 63
    e75a:	08 95       	ret

0000e75c <_exit>:
    e75c:	f8 94       	cli

0000e75e <__stop_program>:
    e75e:	ff cf       	rjmp	.-2      	; 0xe75e <__stop_program>
